<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sonic Lab V5 FINAL</title>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-main: #ccc;
            --accent: #00ffcc;
            --accent-dim: #008866;
            --panic-color: #ff4444;
            --save-color: #ffcc00;
            --guide-color: #ff77dd;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            user-select: none;
            touch-action: none;
            transition: background 0.1s;
        }
        body.panic-active { background-color: #400 !important; }

        /* HEADER */
        header {
            width: 100%; max-width: 940px;
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px;
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; color: #fff; font-size: 1.2rem; }
        h1 span { color: var(--accent); font-weight: bold; font-size: 0.8em; margin-left: 5px; }
        .header-controls { display: flex; gap: 8px; }

        button { font-family: inherit; outline: none; }
        .std-btn {
            background: #333; color: #fff; border: 1px solid #555;
            padding: 5px 12px; border-radius: 4px; cursor: pointer;
            font-size: 0.75rem; transition: 0.2s;
        }
        .std-btn:hover { background: #444; border-color: #777; }
        .std-btn:active { transform: translateY(1px); }

        .panic-btn { border-color: var(--panic-color); color: var(--panic-color); background: rgba(50,0,0,0.3); }
        .panic-btn:active, .panic-btn.flash { background: var(--panic-color); color: #fff; box-shadow: 0 0 15px var(--panic-color); }
        
        .save-btn { border-color: var(--save-color); color: var(--save-color); background: rgba(50,50,0,0.2); }
        .save-btn:hover { background: var(--save-color); color: #000; }

        .key-btn { border-color: var(--guide-color); color: var(--guide-color); }
        .key-btn.active { background: var(--guide-color); color: #000; }

        /* SYNTH PANEL */
        .synth-wrapper {
            background-color: var(--panel-bg);
            border: 1px solid #444; border-radius: 6px;
            padding: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            width: 100%; max-width: 940px;
            box-sizing: border-box;
        }

        /* PRESET BAR */
        .preset-bar {
            display: flex; gap: 6px; margin-bottom: 15px;
            overflow-x: auto; padding-bottom: 5px; align-items: center;
            background: #151515; padding: 8px; border-radius: 4px; border: 1px solid #333;
        }
        .preset-label { font-size: 0.7rem; font-weight: bold; color: #888; margin-right: 5px; }
        .preset-chip {
            display: flex; align-items: center;
            background: #2a2a2a; border: 1px solid #444; border-radius: 3px;
            overflow: hidden; transition: 0.2s;
            flex-shrink: 0;
        }
        .preset-chip.active { border-color: var(--accent); }
        .preset-chip.active .p-name { background: var(--accent-dim); color: #fff; }
        .p-name { padding: 4px 8px; font-size: 0.75rem; cursor: pointer; color: #bbb; white-space: nowrap; }
        .p-name:hover { color: #fff; background: #333; }
        .p-del {
            padding: 4px 6px; font-size: 0.7rem; cursor: pointer;
            color: #666; background: #222; border-left: 1px solid #444;
        }
        .p-del:hover { background: #d00; color: #fff; }

        /* VISUALIZER */
        .visualizer-container {
            background: #000; border: 1px solid #444; border-radius: 4px;
            height: 64px; margin-bottom: 15px; position: relative; cursor: pointer;
        }
        .visualizer-container:hover { border-color: var(--accent); }
        .vis-label {
            position: absolute; top: 4px; right: 6px; font-size: 10px; color: #666; pointer-events: none;
        }
        canvas { width: 100%; height: 100%; display: block; }

        /* CONTROLS */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px; margin-bottom: 15px;
        }
        .module {
            background: #252525; padding: 10px; border-radius: 4px;
            border: 1px solid #3a3a3a;
        }
        .module h3 {
            margin: 0 0 10px 0; font-size: 0.7rem; font-weight: 600;
            color: #888; border-bottom: 2px solid #444; padding-bottom: 4px;
        }
        .param { display: flex; flex-direction: column; margin-bottom: 8px; }
        label { font-size: 0.65rem; margin-bottom: 3px; display: flex; justify-content: space-between; color: #aaa; }
        .val-disp { color: var(--accent); font-family: monospace; font-size: 0.7rem; }

        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 4px;
            background: #111; border-radius: 2px; outline: none; border: 1px solid #444;
            padding: 0; margin: 5px 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 18px;
            background: #ccc; border-radius: 1px; cursor: pointer;
        }
        input[type="range"].accent-slider::-webkit-slider-thumb { background: var(--accent); }
        input[type="range"].rev-slider::-webkit-slider-thumb { background: #d0f; }
        input[type="range"].hpf-slider::-webkit-slider-thumb { background: #fa0; }
        select { width: 100%; background: #111; color: #eee; border: 1px solid #555; padding: 4px; font-size: 0.7rem; }

        /* SEQUENCER STYLES */
        .seq-row {
            display: flex; gap: 4px; margin-top: 5px; justify-content: space-between;
        }
        .seq-step {
            flex: 1; height: 20px; background: #333; border: 1px solid #555;
            border-radius: 2px; cursor: pointer;
        }
        .seq-step.active { background: var(--accent); box-shadow: 0 0 5px var(--accent); border-color: #fff; }
        .seq-step.current { border: 1px solid #fff; }

        /* UTILITY */
        .utility-bar {
            display: flex; justify-content: space-between; align-items: center;
            background: #1a1a1a; padding: 8px; border-radius: 4px; margin-bottom: 0; border: 1px solid #333;
        }
        .rec-btn.active { background: #d00; border-color: #f00; color: #fff; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.7; } }

        /* PIANO */
        .piano-wrapper {
            position: relative; background: #111; border-top: 1px solid #000;
            padding: 10px 0 5px 0; margin-top: 10px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .piano { 
            display: flex; justify-content: center; height: 150px; position: relative;
            min-width: 800px;
        }
        .key { position: relative; border-radius: 0 0 3px 3px; cursor: pointer; display: flex; justify-content: center; align-items: flex-end; padding-bottom: 10px; }
        .key.white { flex: 1; background: #e0e0e0; border: 1px solid #999; z-index: 1; max-width: 50px; }
        .key.white.active { background: #ccc; transform: scaleY(0.98); border-bottom: 4px solid var(--accent); }
        .key.black {
            width: 60%; max-width: 32px; height: 60%; background: #111;
            position: absolute; z-index: 2; left: 0; transform: translateX(-50%);
            border: 1px solid #000; box-shadow: inset 0 0 5px rgba(255,255,255,0.2);
            padding-bottom: 8px;
        }
        .key.black.active { background: #333; transform: translateX(-50%) scaleY(0.98); border-bottom: 2px solid var(--accent); }

        .key-hint {
            font-size: 10px; color: var(--guide-color); font-weight: bold; pointer-events: none; opacity: 0; transition: opacity 0.2s;
        }
        .key.black .key-hint { color: #fff; font-size: 9px; }
        .show-hints .key-hint { opacity: 1; }

        .midi-dot { width: 8px; height: 8px; border-radius: 50%; background: #444; display: inline-block; margin-right: 5px; }
        .midi-dot.on { background: var(--accent); box-shadow: 0 0 8px var(--accent); }

        /* HELP */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 999; display: none;
            justify-content: center; align-items: center;
        }
        .modal-overlay.open { display: flex; }
        .modal-content {
            background: #222; border: 1px solid #555; width: 90%; max-width: 600px;
            max-height: 90vh; overflow-y: auto; padding: 25px; color: #ddd;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .modal-content h2 { border-bottom: 1px solid var(--accent); color: var(--accent); margin-top: 0; padding-bottom: 10px; }
        .modal-content h3 { font-size: 0.95rem; color: #fff; margin-top: 20px; border-left: 3px solid #555; padding-left: 10px; }
        .modal-content p { font-size: 0.85rem; line-height: 1.6; color: #aaa; margin: 5px 0; }
        .close-modal { width: 100%; padding: 10px; background: #333; border: 1px solid #555; color: #fff; margin-top: 20px; cursor: pointer; }

        /* MOBILE RESPONSIVE */
        @media (max-width: 600px) {
            body { padding: 5px; }
            header { flex-direction: column; gap: 10px; align-items: stretch; }
            .header-controls { justify-content: space-between; flex-wrap: wrap; }
            h1 { text-align: center; font-size: 1.1rem; }
            .std-btn { flex: 1; padding: 8px 0; font-size: 0.75rem; min-width: 60px; }
            .synth-wrapper { padding: 10px; }
            .piano { height: 130px; }
            .utility-bar { flex-wrap: wrap; gap: 10px; justify-content: center; }
            .utility-group { flex: 1; display: flex; justify-content: center; min-width: 100px; }
            .modal-content { padding: 15px; width: 95%; }
        }

    </style>
</head>
<body>

    <header>
        <h1>Sonic Lab <span>V5 MASTER</span></h1>
        <div class="header-controls">
            <button class="std-btn" id="init-btn">INIT</button>
            <button class="std-btn key-btn" id="key-btn" title="Show Keyboard Hints">‚å® KEY</button>
            <button class="std-btn save-btn" id="save-btn">üíæ SAVE</button>
            <button class="std-btn panic-btn" id="panic-btn">üõë PANIC</button>
            <button class="std-btn" id="help-btn">HELP</button>
        </div>
    </header>

    <div class="synth-wrapper">
        <div class="preset-bar" id="preset-bar">
            <!-- JS populated -->
        </div>

        <div class="visualizer-container" id="vis-container" title="Click to Switch Mode">
            <span class="vis-label" id="vis-label">WAVEFORM</span>
            <canvas id="scope"></canvas>
        </div>

        <div class="controls-grid">
            <div class="module">
                <h3>VCO</h3>
                <div class="param">
                    <label>Waveform</label>
                    <select id="osc-type">
                        <option value="sawtooth">Sawtooth</option>
                        <option value="square">Square</option>
                        <option value="triangle">Triangle</option>
                        <option value="sine">Sine</option>
                    </select>
                </div>
                <div class="param">
                    <label>Detune <span class="val-disp" id="val-detune">0</span></label>
                    <input type="range" id="osc-detune" min="-50" max="50" value="0">
                </div>
            </div>

            <div class="module">
                <h3>VCF</h3>
                <div class="param">
                    <label>LPF Cutoff <span class="val-disp" id="val-cutoff">2000Hz</span></label>
                    <input type="range" id="filter-cutoff" class="accent-slider" min="50" max="12000" step="10" value="2000">
                </div>
                <div class="param">
                    <label>Resonance <span class="val-disp" id="val-res">1.0</span></label>
                    <input type="range" id="filter-res" min="0" max="20" step="0.1" value="1">
                </div>
                <div class="param">
                    <label style="color:#fa0;">HPF Cutoff <span class="val-disp" id="val-hpf">0Hz</span></label>
                    <input type="range" id="filter-hpf" class="hpf-slider" min="0" max="8000" step="10" value="0">
                </div>
            </div>

            <div class="module">
                <h3>Envelope</h3>
                <div class="param">
                    <label>Attack</label>
                    <input type="range" id="env-atk" min="0.005" max="2" step="0.005" value="0.05">
                </div>
                <div class="param">
                    <label>Decay</label>
                    <input type="range" id="env-dec" min="0.01" max="2" step="0.01" value="0.3">
                </div>
                <div class="param">
                    <label>Sustain</label>
                    <input type="range" id="env-sus" min="0" max="1" step="0.01" value="0.5">
                </div>
                <div class="param">
                    <label>Release</label>
                    <input type="range" id="env-rel" min="0.01" max="5" step="0.01" value="0.5">
                </div>
            </div>

            <div class="module">
                <h3>Mod / Arp</h3>
                <div class="param">
                    <label>LFO Rate <span class="val-disp" id="val-lfo-rate">5Hz</span></label>
                    <input type="range" id="lfo-rate" min="0.1" max="20" step="0.1" value="5">
                </div>
                <div class="param">
                    <label>LFO Depth</label>
                    <input type="range" id="lfo-depth" min="0" max="100" value="0">
                </div>
                <div class="param" style="flex-direction:row; justify-content:space-between; margin-top:5px;">
                    <label>Arp</label>
                    <button class="std-btn" id="arp-toggle" style="padding:2px 6px; font-size:0.6rem;">OFF</button>
                </div>
                <div class="param">
                    <label>Speed <span class="val-disp" id="val-arp-speed">120</span></label>
                    <input type="range" id="arp-speed" min="60" max="600" step="10" value="120">
                </div>
                
                <!-- „Ç∑„Éº„Ç±„É≥„Çµ„Éº / „Éâ„É©„É†ÈÅ∏Êäû -->
                <div class="param">
                    <label>
                        Rhythm Seq
                        <select id="seq-drum-type" style="width:auto; padding:0; height:16px; font-size:10px;">
                            <option value="off">OFF</option>
                            <option value="kick">KICK</option>
                            <option value="snare">SNARE</option>
                            <option value="hihat">HI-HAT</option>
                            <option value="tom">TOM</option>
                        </select>
                    </label>
                    <div class="seq-row" id="seq-row">
                        <!-- JS generated -->
                    </div>
                </div>
            </div>

            <div class="module">
                <h3>FX</h3>
                <div class="param">
                    <label>Delay Mix</label>
                    <input type="range" id="delay-mix" min="0" max="0.7" step="0.01" value="0.2">
                </div>
                <div class="param">
                    <label>Delay Time</label>
                    <input type="range" id="delay-time" min="0.05" max="1.0" step="0.01" value="0.3">
                </div>
                <div class="param">
                    <label style="color:#d0f;">Reverb Mix</label>
                    <input type="range" id="reverb-mix" class="rev-slider" min="0" max="1.5" step="0.01" value="0.0">
                </div>
            </div>
        </div>

        <div class="utility-bar">
            <div class="utility-group">
                <div class="midi-dot" id="midi-dot"></div> <span style="font-size:0.7rem; color:#666;">MIDI</span>
            </div>
            <div class="utility-group">
                <button class="std-btn" id="oct-down">OCT -</button>
                <span id="oct-disp" style="font-family:monospace; padding:0 5px;">0</span>
                <button class="std-btn" id="oct-up">OCT +</button>
            </div>
            <div class="utility-group">
                <select id="rec-format" style="width:auto; margin-right:5px; padding:4px;">
                    <!-- JS populated -->
                </select>
                <button class="std-btn rec-btn" id="rec-btn">‚óè REC</button>
            </div>
        </div>

        <div class="piano-wrapper">
            <div class="piano show-hints" id="piano"></div>
        </div>
    </div>

    <!-- HELP -->
    <div class="modal-overlay" id="help-modal">
        <div class="modal-content">
            <h2>User Manual & Guide</h2>

            <h3>1. VCO (Èü≥„ÅÆ„Ç≠„É£„É©„ÇØ„Çø„Éº)</h3>
            <p>Èü≥„ÅÆ„ÄåÈ£üÊùê„ÄçÈÅ∏„Å≥„Åß„Åô„ÄÇ<br>
                <strong>Sawtooth:</strong> Èã≠„Åè‰∏áËÉΩ„Å™Èü≥„ÄÇ<br>
                <strong>Square:</strong> „Ç≤„Éº„É†È¢®„ÅÆ‰∏≠Á©∫„Å™Èü≥„ÄÇ<br>
                <strong>Triangle/Sine:</strong> ‰∏∏„ÅèÊüî„Çâ„Åã„ÅÑÁ¥îÁ≤ã„Å™Èü≥„ÄÇ<br>
                <span style="color:var(--accent)">‚òÖ Detune:</span> Èü≥„ÇíÈáç„Å≠„Å¶Âéö„Åø„ÇíÂá∫„Åó„Åæ„Åô„ÄÇ
            </p>

            <h3>2. VCF & Env (Èü≥Ëâ≤„Å®Âãï„Åç)</h3>
            <p><strong>Filter:</strong> Cutoff„Çí‰∏ã„Åí„Çã„Å®Èü≥„Åå„Åì„ÇÇ„Çä(Êöó„Åè)„ÄÅ‰∏ä„Åí„Çã„Å®Êòé„Çã„Åè„Å™„Çä„Åæ„Åô„ÄÇ<br>
            <strong>Envelope (ADSR):</strong> ÈçµÁõ§„ÇíÊäº„Åó„ÅüÊôÇ„ÅÆ„ÄåÈü≥Èáè„ÅÆÂ§âÂåñ„Äç„Åß„Åô„ÄÇAttack(Á´ã„Å°‰∏ä„Åå„Çä)„ÄÅRelease(‰ΩôÈüª)„ÅåÈáçË¶Å„Åß„Åô„ÄÇ</p>

            <h3>3. Mod / Arp & Sequencer (Ëá™ÂãïÊºîÂ•è)</h3>
            <p>
                <strong>Arp:</strong> ON„Å´„Åô„Çã„Å®„ÄÅÊäº„Åï„Åà„ÅüÂíåÈü≥„ÇíÂàÜÊï£„Åó„Å¶ÊºîÂ•è„Åó„Åæ„Åô„ÄÇ<br>
                <strong>Rhythm Seq:</strong> 8ÂÄã„ÅÆ„Éú„Çø„É≥„Åß„É™„Ç∫„É†„Çí‰Ωú„Çå„Åæ„Åô„ÄÇÂÖâ„Å£„Å¶„ÅÑ„ÇãÂ†¥ÊâÄ„ÅßÈü≥„ÅåÈ≥¥„Çä„Åæ„Åô„ÄÇ<br>
                <strong>Rhythm Menu:</strong> „Éú„Çø„É≥„ÅÆÊ®™„ÅÆ„É°„Éã„É•„Éº„Åß„ÄÅÈ≥¥„Çâ„Åô„Éâ„É©„É†„ÅÆÁ®ÆÈ°û„ÇíÈÅ∏„Åπ„Åæ„Åô„ÄÇ<br>
                - <strong>KICK:</strong> „Éâ„É≥ÔºÅ(„Éê„Çπ„Éâ„É©„É†)<br>
                - <strong>SNARE:</strong> „Çø„É≥ÔºÅ(„Çπ„Éç„Ç¢)<br>
                - <strong>HI-HAT:</strong> „ÉÅ„ÉÉÔºÅ(„Éè„Ç§„Éè„ÉÉ„Éà)<br>
                - <strong>TOM:</strong> „Éù„É≥ÔºÅ(„Çø„É†)<br>
                ‚Äª OFF‰ª•Â§ñ„ÇíÈÅ∏„Å∂„Å®„ÄÅÈçµÁõ§„ÇíÊäº„Åï„Å™„Åè„Å¶„ÇÇ„É™„Ç∫„É†„ÅåÈ≥¥„ÇäÂßã„ÇÅ„Åæ„Åô„ÄÇ
            </p>

            <h3>4. FX („Ç®„Éï„Çß„ÇØ„Éà)</h3>
            <p><strong>Delay:</strong> „ÇÑ„Åæ„Å≥„ÅìÂäπÊûú„ÄÇ <strong>Reverb:</strong> „Éõ„Éº„É´„ÅÆ„Çà„ÅÜ„Å™ÊÆãÈüø„ÄÇ</p>

            <h3>5. ‰øùÂ≠òÂΩ¢Âºè„Å´„Å§„ÅÑ„Å¶ (REC)</h3>
            <p>
                <strong>WAV (CD Quality):</strong> ÊúÄÈ´òÈü≥Ë≥™„ÄÇPC„Åß„ÅÆÁ∑®ÈõÜÂêë„Åç„ÄÇ<br>
                <strong>MP3 (Lightweight):</strong> ËªΩÈáè„ÅßÊâ±„ÅÑ„ÇÑ„Åô„ÅÑÂΩ¢Âºè„ÄÇSNS„Å™„Å©„Å´„ÄÇ<br>
                <strong>WebM / MP4:</strong> „Éñ„É©„Ç¶„Ç∂Ê®ôÊ∫ñ„ÄÇÂãï‰Ωú„ÅåÊúÄ„ÇÇÂÆâÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
            </p>

            <h3>Âü∫Êú¨Êìç‰Ωú</h3>
            <p>
                <strong>üéπ ÊºîÂ•è:</strong> „Çø„ÉÉ„ÉÅ„ÄÅ„Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØ„ÄÅPC„Ç≠„Éº„Éú„Éº„Éâ„ÄÅMIDI„Ç≠„Éº„Éú„Éº„Éâ„Å´ÂØæÂøú„ÄÇ<br>
                <strong>üñ±Ô∏è Visualizer:</strong> Ê≥¢ÂΩ¢ÁîªÈù¢„ÇØ„É™„ÉÉ„ÇØ„ÅßË°®Á§∫„É¢„Éº„ÉâÂàáÊõø„ÄÇ<br>
                <strong>üõë PANIC:</strong> Èü≥„ÅåÊ≠¢„Åæ„Çâ„Å™„ÅÑÊôÇ„ÅÆÁ∑äÊÄ•ÂÅúÊ≠¢„Éú„Çø„É≥„ÄÇ
            </p>

            <button class="close-modal" id="close-help">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <script>
        // --- PRESETS ---
        const factoryPresets = {
            "Init Saw": { oscType:'sawtooth', cutoff:2000, res:1, hpf:0, atk:0.01, dec:0.3, sus:0.8, rel:0.2, lfoDepth:0, delayMix:0, reverbMix:0, arp:false },
            "Deep Space": { oscType:'sawtooth', cutoff:800, res:3, hpf:100, atk:1.0, dec:2.0, sus:0.6, rel:3.0, lfoDepth:20, delayMix:0.5, reverbMix:1.2, arp:false },
            "Acid Bass": { oscType:'square', cutoff:400, res:12, hpf:0, atk:0.01, dec:0.2, sus:0, rel:0.1, lfoDepth:0, delayMix:0.2, reverbMix:0, arp:false },
            "Pluck Lead": { oscType:'sawtooth', cutoff:3000, res:0, hpf:500, atk:0.01, dec:0.1, sus:0, rel:0.4, lfoDepth:0, delayMix:0.4, reverbMix:0.2, arp:true }
        };

        // --- GLOBAL ---
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        let masterGain, compressor, analyser;
        let delayNode, delayFb, delayMix, revNode, revMix;
        let recStream, mediaRecorder, chunks = [];
        let visMode = 0;
        let noiseBuffer = null; // for snare/hihat

        // Èå≤Èü≥Áî®„Éê„ÉÉ„Éï„Ç°ÔºàWAV/MP3Áî®Ôºâ
        let wavRecNode;
        let wavLeft = [], wavRight = [];
        let isRecording = false;

        const params = {
            oscType: 'sawtooth', detune: 0,
            cutoff: 2000, res: 1, hpf: 0,
            atk: 0.05, dec: 0.3, sus: 0.5, rel: 0.5,
            lfoRate: 5, lfoDepth: 0,
            delayTime: 0.3, delayMix: 0.2, reverbMix: 0.0,
            arpEnabled: false, arpSpeed: 120, arpStyle: 'up',
            octave: 0
        };

        // --- AUDIO ENGINE ---
        function createReverbImpulse(duration, decay) {
            const rate = ctx.sampleRate, len = rate * duration;
            const buffer = ctx.createBuffer(2, len, rate);
            const L = buffer.getChannelData(0), R = buffer.getChannelData(1);
            for(let i=0; i<len; i++) {
                const k = Math.pow(1-i/len, decay);
                L[i] = (Math.random()*2-1)*k; R[i] = (Math.random()*2-1)*k;
            }
            return buffer;
        }

        // --- DRUM ENGINE ---
        function createNoiseBuffer() {
            if(noiseBuffer) return;
            const bufSize = ctx.sampleRate * 2; 
            noiseBuffer = ctx.createBuffer(1, bufSize, ctx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufSize; i++) output[i] = Math.random() * 2 - 1;
        }

        function playDrum(type, time) {
            const t = time || ctx.currentTime;
            const gain = ctx.createGain();
            
            if (type === 'kick') {
                const osc = ctx.createOscillator();
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                gain.gain.setValueAtTime(1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.connect(gain); osc.start(t); osc.stop(t + 0.5);
            } 
            else if (type === 'tom') {
                const osc = ctx.createOscillator();
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                gain.gain.setValueAtTime(0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.connect(gain); osc.start(t); osc.stop(t + 0.5);
            }
            else if (type === 'snare') {
                // Tone
                const osc = ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(250, t);
                const oscGain = ctx.createGain();
                oscGain.gain.setValueAtTime(0.5, t);
                oscGain.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                osc.connect(oscGain); oscGain.connect(gain);
                osc.start(t); osc.stop(t+0.2);

                // Noise
                if(!noiseBuffer) createNoiseBuffer();
                const noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 1000;
                const noiseGain = ctx.createGain();
                noiseGain.gain.setValueAtTime(0.6, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t+0.3);
                noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(gain);
                noise.start(t); noise.stop(t+0.3);
            }
            else if (type === 'hihat') {
                if(!noiseBuffer) createNoiseBuffer();
                const noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 8000;
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t+0.05);
                noise.connect(noiseFilter); noiseFilter.connect(gain);
                noise.start(t); noise.stop(t+0.05);
            }

            gain.connect(masterGain);
        }

        function initAudio() {
            if(masterGain) return;
            masterGain = ctx.createGain(); masterGain.gain.value = 0.5;
            compressor = ctx.createDynamicsCompressor();
            compressor.threshold.value = -24; compressor.knee.value = 30;
            compressor.ratio.value = 12; compressor.attack.value = 0.003; compressor.release.value = 0.25;

            analyser = ctx.createAnalyser(); analyser.fftSize = 2048;

            delayNode = ctx.createDelay(); delayNode.delayTime.value = params.delayTime;
            delayFb = ctx.createGain(); delayFb.gain.value = 0.4;
            delayMix = ctx.createGain(); delayMix.gain.value = params.delayMix;
            delayNode.connect(delayFb); delayFb.connect(delayNode); delayNode.connect(delayMix);

            revNode = ctx.createConvolver(); revNode.buffer = createReverbImpulse(3.5, 2.5);
            revMix = ctx.createGain(); revMix.gain.value = params.reverbMix;

            masterGain.connect(compressor);
            compressor.connect(delayNode); compressor.connect(revNode);
            revNode.connect(revMix);

            const finalMix = ctx.createGain();
            compressor.connect(finalMix); delayMix.connect(finalMix); revMix.connect(finalMix);

            // Create Noise Buffer for Drums
            createNoiseBuffer();

            // WAV/MP3Èå≤Èü≥Áî®ScriptProcessor
            wavRecNode = ctx.createScriptProcessor(4096, 2, 2);
            wavRecNode.onaudioprocess = function(e) {
                if (isRecording) {
                    const L = e.inputBuffer.getChannelData(0);
                    const R = e.inputBuffer.getChannelData(1);
                    wavLeft.push(new Float32Array(L));
                    wavRight.push(new Float32Array(R));
                }
                e.outputBuffer.copyToChannel(e.inputBuffer.getChannelData(0), 0);
                e.outputBuffer.copyToChannel(e.inputBuffer.getChannelData(1), 1);
            };

            finalMix.connect(wavRecNode);
            wavRecNode.connect(analyser); 
            analyser.connect(ctx.destination);
            
            const dest = ctx.createMediaStreamDestination();
            finalMix.connect(dest);
            recStream = dest.stream;

            visualize();
        }

        const activeVoices = {};

        function noteOn(midi, velocity=1, duration=0) {
            initAudio(); if(ctx.state==='suspended') ctx.resume();
            if(document.body.classList.contains('panic-active')) return;
            if(params.arpEnabled) { arpKeys.add(midi); startArp(); return; }
            playOsc(midi, velocity, duration);
        }

        function playOsc(midi, velocity, duration) {
            const pitch = midi + (params.octave*12);
            if(duration===0 && activeVoices[pitch]) noteOff(midi, true);

            const t = ctx.currentTime;
            const freq = 440 * Math.pow(2, (pitch-69)/12);
            
            const osc = ctx.createOscillator(); osc.type = params.oscType;
            osc.frequency.setValueAtTime(freq, t); osc.detune.value = params.detune;
            
            const lpf = ctx.createBiquadFilter(); lpf.type = 'lowpass';
            lpf.frequency.setValueAtTime(params.cutoff, t); lpf.Q.value = params.res;
            
            const hpf = ctx.createBiquadFilter(); hpf.type = 'highpass';
            hpf.frequency.setValueAtTime(params.hpf, t);

            const vca = ctx.createGain(); vca.gain.setValueAtTime(0, t);
            
            const a=params.atk, d=params.dec, s=params.sus;
            if(duration>0) {
                vca.gain.linearRampToValueAtTime(velocity, t+0.005);
                vca.gain.setTargetAtTime(0, t+duration*0.8, 0.05);
            } else {
                vca.gain.linearRampToValueAtTime(velocity, t+a);
                vca.gain.setTargetAtTime(velocity*s, t+a+d, 0.2);
            }

            const lfo = ctx.createOscillator(); lfo.frequency.value = params.lfoRate;
            const lfoAmp = ctx.createGain(); lfoAmp.gain.value = params.lfoDepth;
            lfo.connect(lfoAmp); lfoAmp.connect(osc.frequency); lfo.start(t);

            osc.connect(lpf); lpf.connect(hpf); hpf.connect(vca); vca.connect(masterGain);
            osc.start(t);

            const voice = {osc, lfo, vca, lpf, hpf, pitch};
            if(duration>0) {
                osc.stop(t+duration+0.5); setTimeout(()=>delete activeVoices[pitch], (duration+0.5)*1000);
            } else {
                activeVoices[pitch] = voice; drawKey(midi, true);
            }
        }

        function noteOff(midi, force=false) {
            if(params.arpEnabled && !force) { arpKeys.delete(midi); return; }
            const pitch = midi + (params.octave*12);
            const v = activeVoices[pitch];
            if(v) {
                const t = ctx.currentTime;
                v.vca.gain.cancelScheduledValues(t); v.vca.gain.setValueAtTime(v.vca.gain.value, t);
                v.vca.gain.exponentialRampToValueAtTime(0.001, t+params.rel);
                v.osc.stop(t+params.rel+0.1); v.lfo.stop(t+params.rel+0.1);
                delete activeVoices[pitch]; drawKey(midi, false);
            }
        }

        // --- ARPEGGIATOR & SEQUENCER ---
        const arpKeys = new Set();
        let arpTimer = null, arpIdx = 0;
        const sequence = [1, 1, 1, 1, 1, 1, 1, 1];
        
        // Build Seq UI
        const seqContainer = document.getElementById('seq-row');
        const seqStepsEl = [];
        for(let i=0; i<8; i++) {
            const d = document.createElement('div');
            d.className = 'seq-step active';
            d.onclick = () => {
                sequence[i] = sequence[i] ? 0 : 1;
                d.className = sequence[i] ? 'seq-step active' : 'seq-step';
            };
            seqContainer.appendChild(d); seqStepsEl.push(d);
        }

        function startArp() {
            const drumType = document.getElementById('seq-drum-type').value;
            if(arpKeys.size===0 && drumType === 'off') { clearInterval(arpTimer); arpTimer=null; updateSeqUI(-1); return; }
            
            if(!arpTimer) { 
                arpTimer = setInterval(arpStep, 60000/params.arpSpeed/2);
                arpStep(); 
            }
        }

        function arpStep() {
            const currentStep = arpIdx % 8;
            updateSeqUI(currentStep);

            if (sequence[currentStep] === 1) {
                // Drum
                const drumType = document.getElementById('seq-drum-type').value;
                if(drumType !== 'off') playDrum(drumType, ctx.currentTime);

                // Synth Arp
                if (arpKeys.size > 0) {
                    const keys = Array.from(arpKeys).sort((a,b)=>a-b);
                    let playKeys = params.arpStyle==='down' ? keys.slice().reverse() :
                                   params.arpStyle==='updown' ? keys.concat(keys.slice(0,-1).reverse()) : keys;
                    
                    let note;
                    if(params.arpStyle==='random') note = playKeys[Math.floor(Math.random()*playKeys.length)];
                    else {
                        const noteIdx = Math.floor(arpIdx / 1);
                        note = playKeys[noteIdx % playKeys.length];
                    }

                    const dur = (60/params.arpSpeed)*0.8;
                    playOsc(note+(params.octave*12), 0.8, dur);
                    drawKey(note, true); setTimeout(()=>drawKey(note,false), 100);
                }
            }
            arpIdx++;
        }

        function updateSeqUI(current) {
            seqStepsEl.forEach((el, i) => {
                const isActive = sequence[i] === 1;
                el.className = `seq-step ${isActive ? 'active' : ''} ${i === current ? 'current' : ''}`;
            });
        }
        
        document.getElementById('seq-drum-type').onchange = (e) => {
             if(e.target.value !== 'off') { initAudio(); if(ctx.state==='suspended') ctx.resume(); startArp(); }
             else if(arpKeys.size === 0) { clearInterval(arpTimer); arpTimer=null; updateSeqUI(-1); }
        };

        // --- VISUALIZER ---
        const canvas = document.getElementById('scope');
        const cCtx = canvas.getContext('2d');
        const dataArr = new Uint8Array(2048);
        const visLabel = document.getElementById('vis-label');

        document.getElementById('vis-container').onclick = () => {
            visMode = (visMode + 1) % 2;
            visLabel.innerText = visMode === 0 ? "WAVEFORM" : "SPECTRUM";
        };

        function visualize() {
            requestAnimationFrame(visualize);
            if(canvas.width !== canvas.clientWidth) { canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight; }
            if(!analyser) return;

            cCtx.fillStyle = '#000'; cCtx.fillRect(0,0,canvas.width,canvas.height);
            cCtx.lineWidth = 2; cCtx.strokeStyle = '#00ffcc';

            if(visMode === 0) {
                analyser.getByteTimeDomainData(dataArr);
                cCtx.beginPath();
                const slice = canvas.width/2048; let x=0;
                for(let i=0; i<2048; i++) {
                    const y = (dataArr[i]/128.0)*canvas.height/2;
                    i===0?cCtx.moveTo(x,y):cCtx.lineTo(x,y); x+=slice;
                }
                cCtx.stroke();
            } else {
                analyser.getByteFrequencyData(dataArr);
                const barW = (canvas.width / 128) * 2.5; let x = 0;
                for(let i=0; i<128; i++) {
                    const h = (dataArr[i]/255) * canvas.height;
                    cCtx.fillStyle = `hsl(${i*2}, 100%, 50%)`;
                    cCtx.fillRect(x, canvas.height-h, barW, h);
                    x += barW + 1;
                }
            }
        }

        // --- PRESETS & GUI ---
        const presetBar = document.getElementById('preset-bar');
        let userPresets = JSON.parse(localStorage.getItem('sonic_v5_presets')||'{}');

        function drawPresets() {
            presetBar.innerHTML = '<span class="preset-label">BANK:</span>';
            for(let name in factoryPresets) {
                const c = document.createElement('div'); c.className='preset-chip';
                const b = document.createElement('div'); b.className='p-name'; b.innerText=name;
                b.onclick=()=>loadPreset(factoryPresets[name]);
                c.appendChild(b); presetBar.appendChild(c);
            }
            for(let name in userPresets) {
                const c = document.createElement('div'); c.className='preset-chip active';
                c.style.borderColor='var(--save-color)';
                const b = document.createElement('div'); b.className='p-name'; b.innerText=name;
                b.style.color='var(--save-color)'; b.onclick=()=>loadPreset(userPresets[name]);
                const d = document.createElement('div'); d.className='p-del'; d.innerText='√ó';
                d.onclick=(e)=>{ e.stopPropagation(); if(confirm(`Delete "${name}"?`)){ delete userPresets[name]; localStorage.setItem('sonic_v5_presets', JSON.stringify(userPresets)); drawPresets(); }};
                c.appendChild(b); c.appendChild(d); presetBar.appendChild(c);
            }
        }

        function loadPreset(p) {
            Object.assign(params, p);
            const map = {
                oscType:'osc-type', detune:'osc-detune', cutoff:'filter-cutoff', res:'filter-res', hpf:'filter-hpf',
                atk:'env-atk', dec:'env-dec', sus:'env-sus', rel:'env-rel', lfoRate:'lfo-rate', lfoDepth:'lfo-depth',
                delayMix:'delay-mix', delayTime:'delay-time', reverbMix:'reverb-mix', arpSpeed:'arp-speed'
            };
            for(let k in map) {
                const el = document.getElementById(map[k]);
                if(el && p[k]!==undefined) el.value = p[k];
            }
            toggleArp(p.arpEnabled);
            updateDisplays(); updateParamsRealtime();
        }

        function updateDisplays() {
            document.getElementById('val-detune').innerText = params.detune;
            document.getElementById('val-cutoff').innerText = params.cutoff+'Hz';
            document.getElementById('val-res').innerText = params.res;
            document.getElementById('val-hpf').innerText = params.hpf+'Hz';
            document.getElementById('val-lfo-rate').innerText = params.lfoRate+'Hz';
            document.getElementById('val-arp-speed').innerText = params.arpSpeed;
        }

        function updateParamsRealtime() {
            if(!delayMix) return;
            const t = ctx.currentTime;
            delayMix.gain.setTargetAtTime(params.delayMix, t, 0.1);
            revMix.gain.setTargetAtTime(params.reverbMix, t, 0.1);
            Object.values(activeVoices).forEach(v => {
                v.lpf.frequency.setTargetAtTime(params.cutoff, t, 0.1);
                v.lpf.Q.setTargetAtTime(params.res, t, 0.1);
                v.hpf.frequency.setTargetAtTime(params.hpf, t, 0.1);
            });
        }

        document.querySelectorAll('input[type="range"], select').forEach(el => {
            el.addEventListener('input', e => {
                const id=e.target.id; const v=e.target.type==='range'?parseFloat(e.target.value):e.target.value;
                if(id==='osc-type') params.oscType=v; if(id==='osc-detune') params.detune=v;
                if(id==='filter-cutoff') params.cutoff=v; if(id==='filter-res') params.res=v; if(id==='filter-hpf') params.hpf=v;
                if(id==='env-atk') params.atk=v; if(id==='env-dec') params.dec=v; if(id==='env-sus') params.sus=v; if(id==='env-rel') params.rel=v;
                if(id==='lfo-rate') params.lfoRate=v; if(id==='lfo-depth') params.lfoDepth=v;
                if(id==='delay-mix') params.delayMix=v; if(id==='delay-time') { params.delayTime=v; if(delayNode) delayNode.delayTime.linearRampToValueAtTime(v, ctx.currentTime+0.1); }
                if(id==='reverb-mix') params.reverbMix=v; 
                
                // SPEED CHANGE REALTIME FIX
                if(id==='arp-speed') {
                    params.arpSpeed = v;
                    // If sequence running, restart interval
                    if(arpTimer) {
                        clearInterval(arpTimer);
                        arpTimer = setInterval(arpStep, 60000/params.arpSpeed/2);
                    }
                }
                
                updateDisplays(); updateParamsRealtime();
            });
        });

        const arpBtn = document.getElementById('arp-toggle');
        function toggleArp(state) {
            params.arpEnabled=state; arpBtn.innerText=state?'ON':'OFF';
            arpBtn.style.background = state?'var(--accent)':'#333';
            if(!state && document.getElementById('seq-drum-type').value === 'off') { clearInterval(arpTimer); arpTimer=null; arpKeys.clear(); }
        }
        arpBtn.onclick=()=>toggleArp(!params.arpEnabled);

        document.getElementById('save-btn').onclick = () => {
            const name = prompt("„Éó„É™„Çª„ÉÉ„ÉàÂêç„ÇíÂÖ•Âäõ„Åó„Å¶‰øùÂ≠ò:");
            if(name) { userPresets[name] = {...params}; localStorage.setItem('sonic_v5_presets', JSON.stringify(userPresets)); drawPresets(); }
        };
        document.getElementById('init-btn').onclick = () => { if(confirm("Ë®≠ÂÆö„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åô„ÅãÔºü")) loadPreset(factoryPresets["Init Saw"]); };
        
        const octD = document.getElementById('oct-disp');
        document.getElementById('oct-down').onclick=()=>{if(params.octave>-2)params.octave--; octD.innerText=params.octave;};
        document.getElementById('oct-up').onclick=()=>{if(params.octave<2)params.octave++; octD.innerText=params.octave;};

        const keyBtn = document.getElementById('key-btn');
        const pianoEl = document.getElementById('piano');
        keyBtn.onclick = () => { pianoEl.classList.toggle('show-hints'); keyBtn.classList.toggle('active'); };

        const panicBtn = document.getElementById('panic-btn');
        panicBtn.onclick = () => {
            document.body.classList.add('panic-active'); panicBtn.classList.add('flash');
            if(masterGain) {
                const t=ctx.currentTime; masterGain.gain.cancelScheduledValues(t); masterGain.gain.setValueAtTime(0,t);
                if(delayMix) delayMix.gain.setValueAtTime(0,t); if(revMix) revMix.gain.setValueAtTime(0,t);
            }
            clearInterval(arpTimer); arpTimer=null; arpKeys.clear();
            isRecording=false; wavLeft=[]; wavRight=[];
            Object.values(activeVoices).forEach(v=>{try{v.osc.stop();v.lfo.stop();}catch(e){}});
            for(let k in activeVoices) delete activeVoices[k];
            setTimeout(()=>{
                document.body.classList.remove('panic-active'); panicBtn.classList.remove('flash');
                if(masterGain) masterGain.gain.setTargetAtTime(0.5,ctx.currentTime,0.5);
                if(delayMix) delayMix.gain.setTargetAtTime(params.delayMix,ctx.currentTime,0.5);
                if(revMix) revMix.gain.setTargetAtTime(params.reverbMix,ctx.currentTime,0.5);
            },600);
        };

        // --- KEYS ---
        const keysEl = []; let wC=0;
        const pcKeyMap = "ZSXDCVGBHNJMQ2W3ER5T6Y7UI".split('');
        for(let i=48; i<=72; i++) {
            const isB = [1,3,6,8,10].includes(i%12);
            const k = document.createElement('div'); k.className = `key ${isB?'black':'white'}`; k.dataset.midi = i;
            const hint = document.createElement('span'); hint.className = 'key-hint';
            const char = pcKeyMap[i-48]; if(char) hint.innerText = char;
            k.appendChild(hint);
            if(isB) k.style.left = ((wC*100/15)-(100/15/2))+'%'; else wC++;
            pianoEl.appendChild(k); keysEl.push({midi:i, el:k});
        }
        function drawKey(m,on) {
            const dM=m+(params.octave*-12); const k=keysEl.find(x=>x.midi===dM);
            if(k) on?k.el.classList.add('active'):k.el.classList.remove('active');
        }

        // --- INPUTS ---
        let isDown=false;
        const getM = e => e.target.classList.contains('key')?parseInt(e.target.dataset.midi):e.target.parentNode.classList.contains('key')?parseInt(e.target.parentNode.dataset.midi):null;
        
        pianoEl.addEventListener('mousedown',e=>{isDown=true; const m=getM(e); if(m) noteOn(m);});
        window.addEventListener('mouseup',()=>{isDown=false; keysEl.forEach(k=>{if(k.el.classList.contains('active')&&!params.arpEnabled)noteOff(k.midi);}); if(params.arpEnabled) arpKeys.clear();});
        pianoEl.addEventListener('mouseover',e=>{if(isDown){const m=getM(e); if(m) noteOn(m);}});
        pianoEl.addEventListener('mouseout',e=>{if(isDown){const m=getM(e); if(m) noteOff(m);}});

        // Touch
        const activeTouches = {};
        pianoEl.addEventListener('touchstart', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                const t = e.changedTouches[i]; const el = document.elementFromPoint(t.clientX, t.clientY);
                if(el) { const m = getM({target: el}); if(m!==null) { noteOn(m); activeTouches[t.identifier] = m; }}
            }
        }, {passive: false});

        pianoEl.addEventListener('touchmove', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                const t = e.changedTouches[i]; const el = document.elementFromPoint(t.clientX, t.clientY);
                const oldM = activeTouches[t.identifier]; let newM = null;
                if(el) newM = getM({target: el});
                if(newM !== null && oldM !== newM) {
                    if(oldM !== undefined) noteOff(oldM); noteOn(newM); activeTouches[t.identifier] = newM;
                }
            }
        }, {passive: false});

        pianoEl.addEventListener('touchend', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                const t = e.changedTouches[i]; const m = activeTouches[t.identifier];
                if(m !== undefined) { noteOff(m); delete activeTouches[t.identifier]; }
            }
        });

        // PC Key
        const kMap={}; pcKeyMap.forEach((k,i)=>kMap[k]=48+i);
        window.addEventListener('keydown',e=>{if(!e.repeat&&kMap[e.key.toUpperCase()]) noteOn(kMap[e.key.toUpperCase()]);});
        window.addEventListener('keyup',e=>{if(kMap[e.key.toUpperCase()]) noteOff(kMap[e.key.toUpperCase()]);});

        // MIDI
        if(navigator.requestMIDIAccess) navigator.requestMIDIAccess().then(a=>{a.inputs.forEach(i=>i.onmidimessage=m=>{const[c,n,v]=m.data; if(c===144&&v>0){noteOn(n,v/127); document.getElementById('midi-dot').classList.add('on');} if(c===128||(c===144&&v===0)){noteOff(n); document.getElementById('midi-dot').classList.remove('on');}});});

        // --- RECORDER ---
        const recBtn = document.getElementById('rec-btn');
        const recSelect = document.getElementById('rec-format');
        
        const optWav = document.createElement('option'); optWav.value = 'wav'; optWav.innerText = 'WAV (CD Quality)'; recSelect.appendChild(optWav);
        const optMp3 = document.createElement('option'); optMp3.value = 'mp3'; optMp3.innerText = 'MP3 (Lightweight)'; recSelect.appendChild(optMp3);
        const supportedTypes = [{ type: 'audio/webm', ext: 'webm', label: 'WebM (Browser)' }, { type: 'audio/mp4',  ext: 'mp4',  label: 'MP4 (Safari)' }];
        supportedTypes.forEach(t => { if (MediaRecorder.isTypeSupported(t.type)) { const opt = document.createElement('option'); opt.value = t.type; opt.innerText = t.label; opt.dataset.ext = t.ext; recSelect.appendChild(opt); }});

        recBtn.onclick = () => {
            initAudio();
            if (!recBtn.classList.contains('active')) {
                const type = recSelect.value;
                if (type === 'wav' || type === 'mp3') { wavLeft = []; wavRight = []; isRecording = true; }
                else {
                    chunks = [];
                    try { mediaRecorder = new MediaRecorder(recStream, { mimeType: type }); } catch(e) { alert("Format Error"); return; }
                    mediaRecorder.ondataavailable = e => chunks.push(e.data);
                    mediaRecorder.start();
                }
                recBtn.classList.add('active'); recBtn.innerText = '‚ñ† STOP'; recSelect.disabled = true;
            } else {
                const f = prompt("‰øùÂ≠ò„Éï„Ç°„Ç§„É´Âêç:", `sonic_rec_${Date.now()}`);
                if (!f) {
                     isRecording = false; 
                     if(mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop();
                     recBtn.classList.remove('active'); recBtn.innerText = '‚óè REC'; recSelect.disabled = false;
                     return;
                }

                const type = recSelect.value;
                if (type === 'wav') {
                    isRecording = false;
                    const blob = exportWAV(wavLeft, wavRight);
                    saveBlob(blob, f + ".wav");
                    wavLeft = []; wavRight = [];
                } else if (type === 'mp3') {
                    isRecording = false; recBtn.innerText = 'Encoding...';
                    setTimeout(() => {
                        const blob = exportMP3(wavLeft, wavRight);
                        if(blob) saveBlob(blob, f + ".mp3");
                        wavLeft = []; wavRight = [];
                        recBtn.classList.remove('active'); recBtn.innerText = '‚óè REC'; recSelect.disabled = false;
                    }, 50);
                    return; 
                } else {
                    mediaRecorder.onstop = () => {
                        const ext = recSelect.options[recSelect.selectedIndex].dataset.ext;
                        const blob = new Blob(chunks, { type: type });
                        saveBlob(blob, f + "." + ext);
                    };
                    mediaRecorder.stop();
                }

                if(type !== 'mp3') { recBtn.classList.remove('active'); recBtn.innerText = '‚óè REC'; recSelect.disabled = false; }
            }
        };

        function saveBlob(blob, filename) {
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click();
        }

        // --- EXPORT UTIL ---
        function writeString(view, offset, string) { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); }
        
        function exportWAV(leftBuffers, rightBuffers) {
            const bufferLen = leftBuffers.reduce((acc, b) => acc + b.length, 0);
            const L = new Float32Array(bufferLen); const R = new Float32Array(bufferLen);
            let offset = 0;
            for (let i=0; i<leftBuffers.length; i++) { L.set(leftBuffers[i], offset); R.set(rightBuffers[i], offset); offset += leftBuffers[i].length; }
            const interleaved = new Int16Array(bufferLen * 2);
            for (let i=0; i<bufferLen; i++) {
                let sL = Math.max(-1, Math.min(1, L[i])); let sR = Math.max(-1, Math.min(1, R[i]));
                interleaved[i*2] = sL < 0 ? sL * 0x8000 : sL * 0x7FFF; interleaved[i*2+1] = sR < 0 ? sR * 0x8000 : sR * 0x7FFF;
            }
            const buffer = new ArrayBuffer(44 + interleaved.length * 2); const view = new DataView(buffer);
            writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + interleaved.length * 2, true); writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 2, true);
            view.setUint32(24, ctx.sampleRate, true); view.setUint32(28, ctx.sampleRate * 4, true); view.setUint16(32, 4, true); view.setUint16(34, 16, true);
            writeString(view, 36, 'data'); view.setUint32(40, interleaved.length * 2, true);
            const payload = new Uint8Array(buffer, 44); payload.set(new Uint8Array(interleaved.buffer));
            return new Blob([buffer], { type: 'audio/wav' });
        }

        function exportMP3(leftBuffers, rightBuffers) {
            if(typeof lamejs === 'undefined') { alert("MP3 Library not loaded."); return null; }
            const bufferLen = leftBuffers.reduce((acc, b) => acc + b.length, 0);
            const samplesL = new Int16Array(bufferLen); const samplesR = new Int16Array(bufferLen);
            let offset = 0;
            for (let i = 0; i < leftBuffers.length; i++) {
                const bL = leftBuffers[i]; const bR = rightBuffers[i];
                for(let j=0; j<bL.length; j++) {
                    let sL = Math.max(-1, Math.min(1, bL[j])); let sR = Math.max(-1, Math.min(1, bR[j]));
                    samplesL[offset + j] = sL < 0 ? sL * 0x8000 : sL * 0x7FFF; samplesR[offset + j] = sR < 0 ? sR * 0x8000 : sR * 0x7FFF;
                }
                offset += bL.length;
            }
            const mp3encoder = new lamejs.Mp3Encoder(2, ctx.sampleRate || 44100, 128);
            const mp3Data = []; const sampleBlockSize = 1152;
            for (let i = 0; i < samplesL.length; i += sampleBlockSize) {
                const leftChunk = samplesL.subarray(i, i + sampleBlockSize); const rightChunk = samplesR.subarray(i, i + sampleBlockSize);
                const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
                if (mp3buf.length > 0) mp3Data.push(mp3buf);
            }
            const mp3buf = mp3encoder.flush(); if (mp3buf.length > 0) mp3Data.push(mp3buf);
            return new Blob(mp3Data, { type: 'audio/mp3' });
        }

        const modal=document.getElementById('help-modal');
        document.getElementById('help-btn').onclick=()=>modal.classList.add('open');
        document.getElementById('close-help').onclick=()=>modal.classList.remove('open');
        modal.onclick=(e)=>{if(e.target===modal)modal.classList.remove('open');};

        drawPresets(); updateDisplays();
    </script>
</body>
</html>
